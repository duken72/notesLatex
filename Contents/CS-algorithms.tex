% !TeX spellcheck = en_US
\chapter{CS Algorithms}

\section{Sorting}

References:
\begin{itemize}
	\item \href{https://youtu.be/OOBBI-kSChM}{BATTLE OF THE SORTS: which sorting algorithm is the fastest? (visualization)}
	\item \href{https://stackoverflow.com/q/5038895/11397588}{stackoverflow}
	\item \href{https://www.cprogramming.com/tutorial/computersciencetheory/sortcomp.html}{cprogramming.com}
\end{itemize}

Sorting algorithms:
\begin{itemize}
	\item Selection sort: finds the next smallest element
	\item Bubble sort: swaps adjacent out-of-order elements
	\item Insertion Sort: inserts next element into its place
	\item Heap Sort: Selection sort with a heap
	\item Merge Sort: Divide and conquer method
\begin{lstlisting}[language=C++]
void merge(
int a[], const int left, const int mid, const int right);	

void mergeSort(int a[], const int begin, const int end)
{
	if (begin >= end)
	return;
	
	int mid = begin + (end - begin) / 2;
	mergeSort(a, begin, mid);
	mergeSort(a, mid + 1, end);
	merge(array, begin, mid, end);
}
\end{lstlisting}
	\item Timsort: A hybrid version of Insertion and Merge sort.
	\item Quick Sort: swaps elements around a pivot
	\item IntroSort: A hybrid version of Insertion, Quick and heap sort
\end{itemize}

\section{Complete Search}
\begin{itemize}
	\item Keep it simple, stupid
	\item Brute force within the time allowed
	\item Can search in either the input space or the output space
\end{itemize}

\section{Greedy Search}
\begin{itemize}
	\item Constructs a solution by always making a choice that looks the best at the moment
	\item Is FAST, generally linear to quadratic
	\item Requires little extra memory
	\item Is usually not correct. But when it works, it's easy and fast to implement
\end{itemize}

\section{More Search Techniques}
\begin{itemize}
	\item \ac{DFS}
	\item \ac{BFS}
	\item Depth First with Iterative Deepening
\end{itemize}

\section{Flood Fill}
\begin{itemize}
	\item Given a graph, find the all connected sub-graphs / components
	\item Can be performed via 3 basic ways: depth-first, breadth-first, breadth-first scanning
	\begin{itemize}
		\item Depth-first: if current node is not visited yet, visit it, assign to a new component, recurses over all of its unvisited neighbors. However, it is bad with implicit graph
		\item Breath-first: instead of recursing on the newly assigned nodes, add them to a queue.
		\item Both depth-first and breadth-first run in $\mathcal{O}(N + M)$
		\item Breath-first scanning, despite being a little tricky, requires no extra space. However, it is slower, $\mathcal{O}(N * N + M)$
	\end{itemize}
\end{itemize}

\section{Backtracking}
\begin{itemize}
	\item Backtracking can be defined as a general algorithmic technique that considers searching every possible combination in order to solve a computational problem.
	\item Backtracking uses recursive calling to find the solution by building a solution step by step increasing values with time.
	\item It removes the solutions that doesn't give rise to the final solution of the problem based on the given constraints.
\end{itemize}

\section{Dynamic Programming}
\begin{itemize}
	\item Dynamic Programming is an optimization over plain recursion.
	\item It is the approach of breaking down a problem into simpler and repeated sub-problems.
	\item The solutions to each sub-problem are stored so that each of them is only solved once.
\end{itemize}

\href{https://youtu.be/aPQY__2H3tE}{Steps:}
\begin{itemize}
	\item Visualize examples
	\item Find suitable sub-problem
	\item Find relationships among sub-problems
	\item Generalize the relationship
\end{itemize}